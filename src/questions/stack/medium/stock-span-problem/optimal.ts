/**
 * Stock Span Problem - OPTIMAL SOLUTION
 *
 * Approach: Monotonic Decreasing Stack (Previous Greater Element)
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 *
 * KEY INSIGHT:
 * Span[i] = i - index of Previous Greater Element (PGE)
 *
 * If no PGE exists (no larger element to left):
 *   Span[i] = i + 1 (all previous days + current)
 *
 * We use a Monotonic DECREASING Stack to find PGE efficiently.
 * Stack stores INDICES (to calculate span = current index - PGE index)
 */

namespace StockSpanOptimal {
    /**
     * Main function - Calculate stock span for each day
     *
     * @param arr - Array of stock prices
     * @returns Array of spans for each day
     */
    export function stockSpan(arr: number[]): number[] {
        const n = arr.length;
        const span: number[] = [];

        // Monotonic DECREASING Stack
        // WHY decreasing? We want Previous GREATER Element (PGE)
        // Stack stores INDICES (not values)
        // WHY indices? To calculate span = i - PGE_index
        const stack: number[] = [];

        for (let i = 0; i < n; i++) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // STEP 1: Pop elements with price <= current price
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // WHY pop? These elements can't be PGE for current element
            //          (PGE must be STRICTLY GREATER)
            //
            // WHY <= and not <? Because if price is EQUAL, it's not GREATER
            //                   We need STRICTLY greater element
            //
            // Also: These popped elements won't be PGE for any future element
            //       (current element is >= them and is closer to future elements)
            while (stack.length > 0 && arr[stack[stack.length - 1]] <= arr[i]) {
                stack.pop();
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // STEP 2: Calculate span
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (stack.length === 0) {
                // No PGE exists
                // All previous days have price <= current
                // Span = all previous days + current = i + 1
                span.push(i + 1);
            } else {
                // Stack top is the PGE (first greater element to the left)
                // Span = current index - PGE index
                span.push(i - stack[stack.length - 1]);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // STEP 3: Push current index to stack
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Current element might be PGE for future elements
            stack.push(i);
        }

        return span;
    }

    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * DRY RUN - COMPLETE VISUALIZATION
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * Example: arr = [120, 100, 60, 80, 90, 110, 115]
     *                   0    1   2   3   4    5    6
     *
     * Stack stores INDICES
     * Stack maintains DECREASING order of prices
     *
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * ITERATION BY ITERATION
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * i = 0, price = 120
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * Stack: []
     *
     * Step 1: Pop condition - stack empty, nothing to pop
     *
     * Step 2: Stack empty â†’ No PGE
     *         span = i + 1 = 0 + 1 = 1
     *
     * Step 3: Push 0 â†’ Stack: [0]
     *                  prices: [120]
     *
     * span = [1]
     *
     * Visual:
     *   prices: [120]
     *   stack:  [  0]  â† index 0 (price 120)
     *
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * i = 1, price = 100
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * Stack: [0]  (prices: [120])
     *
     * Step 1: arr[0]=120 <= 100? NO (120 > 100)
     *         Don't pop. 120 is greater, it's the PGE!
     *
     * Step 2: Stack not empty â†’ PGE exists at index 0
     *         span = i - stack.top = 1 - 0 = 1
     *
     * Step 3: Push 1 â†’ Stack: [0, 1]
     *                  prices: [120, 100]
     *
     * span = [1, 1]
     *
     * Visual:
     *   prices: [120, 100]
     *   stack:  [  0,   1]  â† maintaining decreasing order
     *
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * i = 2, price = 60
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * Stack: [0, 1]  (prices: [120, 100])
     *
     * Step 1: arr[1]=100 <= 60? NO (100 > 60)
     *         Don't pop.
     *
     * Step 2: PGE at index 1
     *         span = 2 - 1 = 1
     *
     * Step 3: Push 2 â†’ Stack: [0, 1, 2]
     *                  prices: [120, 100, 60]
     *
     * span = [1, 1, 1]
     *
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * i = 3, price = 80
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * Stack: [0, 1, 2]  (prices: [120, 100, 60])
     *
     * Step 1: arr[2]=60 <= 80? YES! Pop 2
     *         Stack: [0, 1]
     *
     *         arr[1]=100 <= 80? NO (100 > 80)
     *         Stop popping.
     *
     *         WHY pop 60? It can't be PGE for 80 or any future element
     *                     (80 is greater and closer to future)
     *
     * Step 2: PGE at index 1
     *         span = 3 - 1 = 2
     *
     * Step 3: Push 3 â†’ Stack: [0, 1, 3]
     *                  prices: [120, 100, 80]
     *
     * span = [1, 1, 1, 2]
     *
     * Visual:
     *   Before: Stack [0, 1, 2] â†’ prices [120, 100, 60]
     *   After:  Stack [0, 1, 3] â†’ prices [120, 100, 80]
     *                                            â†‘
     *                                    60 replaced by 80
     *
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * i = 4, price = 90
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * Stack: [0, 1, 3]  (prices: [120, 100, 80])
     *
     * Step 1: arr[3]=80 <= 90? YES! Pop 3
     *         Stack: [0, 1]
     *
     *         arr[1]=100 <= 90? NO (100 > 90)
     *         Stop popping.
     *
     * Step 2: PGE at index 1
     *         span = 4 - 1 = 3
     *
     * Step 3: Push 4 â†’ Stack: [0, 1, 4]
     *                  prices: [120, 100, 90]
     *
     * span = [1, 1, 1, 2, 3]
     *
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * i = 5, price = 110
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * Stack: [0, 1, 4]  (prices: [120, 100, 90])
     *
     * Step 1: arr[4]=90 <= 110? YES! Pop 4
     *         Stack: [0, 1]
     *
     *         arr[1]=100 <= 110? YES! Pop 1
     *         Stack: [0]
     *
     *         arr[0]=120 <= 110? NO (120 > 110)
     *         Stop popping.
     *
     * Step 2: PGE at index 0
     *         span = 5 - 0 = 5
     *
     * Step 3: Push 5 â†’ Stack: [0, 5]
     *                  prices: [120, 110]
     *
     * span = [1, 1, 1, 2, 3, 5]
     *
     * Visual:
     *   Before: Stack [0, 1, 4] â†’ prices [120, 100, 90]
     *   After:  Stack [0, 5]    â†’ prices [120, 110]
     *
     *   100 and 90 were popped because 110 > both of them!
     *   They can never be PGE for any future element.
     *
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * i = 6, price = 115
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * Stack: [0, 5]  (prices: [120, 110])
     *
     * Step 1: arr[5]=110 <= 115? YES! Pop 5
     *         Stack: [0]
     *
     *         arr[0]=120 <= 115? NO (120 > 115)
     *         Stop popping.
     *
     * Step 2: PGE at index 0
     *         span = 6 - 0 = 6
     *
     * Step 3: Push 6 â†’ Stack: [0, 6]
     *                  prices: [120, 115]
     *
     * span = [1, 1, 1, 2, 3, 5, 6]
     *
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * FINAL OUTPUT: [1, 1, 1, 2, 3, 5, 6] âœ“
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * STACK STATE SUMMARY
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
     * â”‚   i   â”‚  Price  â”‚  Stack Before   â”‚     Stack After     â”‚  Span  â”‚
     * â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     * â”‚   0   â”‚   120   â”‚ []              â”‚ [0]                 â”‚   1    â”‚
     * â”‚   1   â”‚   100   â”‚ [0]             â”‚ [0, 1]              â”‚   1    â”‚
     * â”‚   2   â”‚    60   â”‚ [0, 1]          â”‚ [0, 1, 2]           â”‚   1    â”‚
     * â”‚   3   â”‚    80   â”‚ [0, 1, 2]       â”‚ [0, 1, 3]  (pop 2)  â”‚   2    â”‚
     * â”‚   4   â”‚    90   â”‚ [0, 1, 3]       â”‚ [0, 1, 4]  (pop 3)  â”‚   3    â”‚
     * â”‚   5   â”‚   110   â”‚ [0, 1, 4]       â”‚ [0, 5]    (pop 4,1) â”‚   5    â”‚
     * â”‚   6   â”‚   115   â”‚ [0, 5]          â”‚ [0, 6]     (pop 5)  â”‚   6    â”‚
     * â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     *
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * WHY O(n) TIME?
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * Even with while loop inside for loop:
     *
     * - Each element is PUSHED exactly once
     * - Each element is POPPED at most once
     *
     * Total operations across ALL iterations:
     *   Pushes: n
     *   Pops: â‰¤ n
     *   Total: â‰¤ 2n = O(n)
     *
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * WHY MONOTONIC DECREASING?
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * We need Previous GREATER Element (PGE).
     * Stack top should be the first GREATER element to the left.
     *
     * If we maintain DECREASING order:
     *   Stack: [120, 100, 60] (decreasing prices)
     *
     *   For new element 80:
     *   - Pop 60 (60 < 80, not greater)
     *   - Stop at 100 (100 > 80, this is PGE!)
     *
     * Stack top = PGE âœ“
     *
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * VISUAL: STACK AS "WALLS"
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * Price
     *   â†‘
     * 120â”‚ â–ˆâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Wall: never popped)
     *    â”‚
     * 115â”‚                         â–ˆ
     * 110â”‚                    â–ˆ (popped by 115)
     * 100â”‚     â–ˆ (popped by 110)
     *  90â”‚              â–ˆ (popped by 110)
     *  80â”‚         â–ˆ (popped by 90)
     *  60â”‚    â–ˆ (popped by 80)
     *    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Day
     *        0   1   2   3   4   5   6
     *
     * Each "wall" blocks the span until a taller wall comes.
     * Shorter walls get "demolished" (popped) by taller new walls.
     *
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * EDGE CASES
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * 1. All increasing: [1, 2, 3, 4, 5]
     *    Each element pops all previous â†’ Stack always has 1 element
     *    span = [1, 2, 3, 4, 5]
     *
     * 2. All decreasing: [5, 4, 3, 2, 1]
     *    No pops happen â†’ Stack grows to n elements
     *    span = [1, 1, 1, 1, 1]
     *
     * 3. All same: [3, 3, 3, 3]
     *    <= means equal elements get popped too
     *    span = [1, 2, 3, 4]
     */

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST CASES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    export function runTests(): void {
        console.log('ğŸ§ª Testing Stock Span Problem - OPTIMAL (Monotonic Stack)\n');

        const tests: Array<{ arr: number[]; expected: number[]; description: string }> = [
            {
                arr: [120, 100, 60, 80, 90, 110, 115],
                expected: [1, 1, 1, 2, 3, 5, 6],
                description: "Example 1"
            },
            {
                arr: [15, 13, 12, 14, 16, 20],
                expected: [1, 1, 1, 3, 5, 6],
                description: "Example 2"
            },
            {
                arr: [10],
                expected: [1],
                description: "Single element"
            },
            {
                arr: [5, 10],
                expected: [1, 2],
                description: "Two elements - increasing"
            },
            {
                arr: [10, 5],
                expected: [1, 1],
                description: "Two elements - decreasing"
            },
            {
                arr: [1, 2, 3, 4, 5],
                expected: [1, 2, 3, 4, 5],
                description: "Strictly increasing"
            },
            {
                arr: [5, 4, 3, 2, 1],
                expected: [1, 1, 1, 1, 1],
                description: "Strictly decreasing"
            },
            {
                arr: [3, 3, 3, 3],
                expected: [1, 2, 3, 4],
                description: "All same elements"
            },
            {
                arr: [100, 80, 60, 70, 60, 75, 85],
                expected: [1, 1, 1, 2, 1, 4, 6],
                description: "Mixed pattern"
            },
            {
                arr: [10, 4, 5, 90, 120, 80],
                expected: [1, 1, 2, 4, 5, 1],
                description: "Peak in middle"
            },
            {
                arr: [31, 27, 14, 21, 30, 22],
                expected: [1, 1, 1, 2, 4, 1],
                description: "Another pattern"
            },
            {
                arr: [50, 50, 50, 50, 50],
                expected: [1, 2, 3, 4, 5],
                description: "All equal (tests <=)"
            }
        ];

        let passed = 0;
        let failed = 0;

        tests.forEach((test, index) => {
            const result = stockSpan(test.arr);
            const isEqual = JSON.stringify(result) === JSON.stringify(test.expected);
            const status = isEqual ? 'âœ… PASS' : 'âŒ FAIL';

            if (isEqual) {
                passed++;
            } else {
                failed++;
            }

            console.log(`Test ${index + 1}: ${status}`);
            console.log(`  Description: ${test.description}`);
            console.log(`  Input:       [${test.arr.join(', ')}]`);
            console.log(`  Expected:    [${test.expected.join(', ')}]`);
            console.log(`  Got:         [${result.join(', ')}]`);
            console.log();
        });

        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log(`Total Tests: ${tests.length}`);
        console.log(`âœ… Passed: ${passed}`);
        console.log(`âŒ Failed: ${failed}`);
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

        if (failed === 0) {
            console.log('ğŸ‰ All tests passed! Monotonic Stack mastered! ğŸš€\n');
        }
    }
}

// Execute tests
StockSpanOptimal.runTests();