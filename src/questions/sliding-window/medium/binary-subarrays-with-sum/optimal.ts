/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * BINARY SUBARRAYS WITH SUM - SLIDING WINDOW (OPTIMAL)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Problem: Count number of subarrays with sum exactly equal to goal
 *          (Binary array - only 0s and 1s)
 *
 * Key Insight: THE "AT MOST K" TRICK!
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   exactly(goal) = atMost(goal) - atMost(goal - 1)
 *
 *   WHY?
 *   - atMost(goal) counts subarrays with sum: 0, 1, 2, ..., goal
 *   - atMost(goal-1) counts subarrays with sum: 0, 1, 2, ..., goal-1
 *   - Subtracting removes all except exactly goal!
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * HOW "AT MOST K" COUNTING WORKS:
 *
 *   For each valid window [left, right]:
 *     count += right - left + 1
 *
 *   This counts ALL valid subarrays ending at 'right'!
 *
 *   Example: Window [left=1, right=4] is valid
 *     Subarrays ending at right=4:
 *     - [1...4], [2...4], [3...4], [4...4]
 *     - Total = 4 = right - left + 1
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * Time Complexity: O(n) - two passes, each element visited at most twice
 * Space Complexity: O(1) - only using variables
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

namespace BinarySubarraysWithSumOptimal {
  /**
   * Count subarrays with sum exactly equal to goal - SLIDING WINDOW
   *
   * @param nums - Binary array (only 0s and 1s)
   * @param goal - Target sum
   * @returns Number of subarrays with sum = goal
   */
  function numSubarraysWithSum(nums: number[], goal: number): number {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THE MAGIC TRICK:
    // exactly(goal) = atMost(goal) - atMost(goal - 1)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    return atMost(nums, goal) - atMost(nums, goal - 1);
  }

  /**
   * Count subarrays with sum AT MOST k
   *
   * This is the core helper function that makes the trick work!
   *
   * @param nums - Binary array
   * @param k - Maximum sum allowed
   * @returns Number of subarrays with sum <= k
   */
  function atMost(nums: number[], k: number): number {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // EDGE CASE: k < 0 means no valid subarrays possible
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // This happens when goal = 0, and we call atMost(goal - 1) = atMost(-1)
    // No subarray can have negative sum, so return 0
    if (k < 0) {
      return 0;
    }

    let count = 0;
    let sum = 0;
    let left = 0;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SLIDING WINDOW: Expand with right pointer
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    for (let right = 0; right < nums.length; right++) {
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 1: EXPAND - Add current element to sum
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      sum += nums[right];

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 2: SHRINK - While sum exceeds k, remove from left
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      while (sum > k) {
        sum -= nums[left];
        left++;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 3: COUNT - All subarrays ending at 'right' with sum <= k
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  WHY (right - left + 1)?                                   â”‚
      // â”‚                                                            â”‚
      // â”‚  Window: [left ... right] is valid (sum <= k)              â”‚
      // â”‚                                                            â”‚
      // â”‚  All these subarrays ending at 'right' are also valid:     â”‚
      // â”‚    [left, left+1, ..., right]                              â”‚
      // â”‚    [left+1, left+2, ..., right]                            â”‚
      // â”‚    [left+2, left+3, ..., right]                            â”‚
      // â”‚    ...                                                     â”‚
      // â”‚    [right-1, right]                                        â”‚
      // â”‚    [right]                                                 â”‚
      // â”‚                                                            â”‚
      // â”‚  Count = right - left + 1                                  â”‚
      // â”‚                                                            â”‚
      // â”‚  Example: left=2, right=5                                  â”‚
      // â”‚    Subarrays: [2-5], [3-5], [4-5], [5-5]                   â”‚
      // â”‚    Count = 5 - 2 + 1 = 4 âœ…                                â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      count += right - left + 1;
    }

    return count;
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN - COMPLETE VISUALIZATION
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Example: nums = [1, 0, 1, 0, 1], goal = 2
   *          Index:  0  1  2  3  4
   *
   * We need: exactly(2) = atMost(2) - atMost(1)
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * STEP 1: Calculate atMost(2)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Count all subarrays with sum â‰¤ 2
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 0, nums[0] = 1
   *   EXPAND: sum = 0 + 1 = 1
   *   sum(1) â‰¤ k(2) âœ… No shrink needed
   *   count += right - left + 1 = 0 - 0 + 1 = 1
   *   count = 1
   *
   *   Window: [1] 0 1 0 1
   *            L
   *            R
   *   Valid subarrays ending at R: [1]
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 1, nums[1] = 0
   *   EXPAND: sum = 1 + 0 = 1
   *   sum(1) â‰¤ k(2) âœ… No shrink needed
   *   count += 1 - 0 + 1 = 2
   *   count = 1 + 2 = 3
   *
   *   Window: [1 0] 1 0 1
   *            L R
   *   Valid subarrays ending at R: [1,0], [0]
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 2, nums[2] = 1
   *   EXPAND: sum = 1 + 1 = 2
   *   sum(2) â‰¤ k(2) âœ… No shrink needed
   *   count += 2 - 0 + 1 = 3
   *   count = 3 + 3 = 6
   *
   *   Window: [1 0 1] 0 1
   *            L   R
   *   Valid subarrays ending at R: [1,0,1], [0,1], [1]
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 3, nums[3] = 0
   *   EXPAND: sum = 2 + 0 = 2
   *   sum(2) â‰¤ k(2) âœ… No shrink needed
   *   count += 3 - 0 + 1 = 4
   *   count = 6 + 4 = 10
   *
   *   Window: [1 0 1 0] 1
   *            L     R
   *   Valid subarrays ending at R: [1,0,1,0], [0,1,0], [1,0], [0]
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 4, nums[4] = 1
   *   EXPAND: sum = 2 + 1 = 3
   *   sum(3) > k(2) âŒ Must shrink!
   *
   *   SHRINK:
   *     Remove nums[0]=1: sum = 3 - 1 = 2, left = 1
   *     sum(2) â‰¤ k(2) âœ… Stop shrinking
   *
   *   count += 4 - 1 + 1 = 4
   *   count = 10 + 4 = 14
   *
   *   Window: 1 [0 1 0 1]
   *              L     R
   *   Valid subarrays ending at R: [0,1,0,1], [1,0,1], [0,1], [1]
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * atMost(2) = 14
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * STEP 2: Calculate atMost(1)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Count all subarrays with sum â‰¤ 1
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 0, nums[0] = 1
   *   sum = 1 â‰¤ 1 âœ…
   *   count += 0 - 0 + 1 = 1
   *   count = 1
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 1, nums[1] = 0
   *   sum = 1 + 0 = 1 â‰¤ 1 âœ…
   *   count += 1 - 0 + 1 = 2
   *   count = 3
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 2, nums[2] = 1
   *   sum = 1 + 1 = 2 > 1 âŒ Must shrink!
   *
   *   SHRINK:
   *     Remove nums[0]=1: sum = 2 - 1 = 1, left = 1
   *     sum(1) â‰¤ 1 âœ… Stop
   *
   *   count += 2 - 1 + 1 = 2
   *   count = 5
   *
   *   Window: 1 [0 1] 0 1
   *              L R
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 3, nums[3] = 0
   *   sum = 1 + 0 = 1 â‰¤ 1 âœ…
   *   count += 3 - 1 + 1 = 3
   *   count = 8
   *
   *   Window: 1 [0 1 0] 1
   *              L   R
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * right = 4, nums[4] = 1
   *   sum = 1 + 1 = 2 > 1 âŒ Must shrink!
   *
   *   SHRINK:
   *     Remove nums[1]=0: sum = 2 - 0 = 2 > 1, left = 2
   *     Remove nums[2]=1: sum = 2 - 1 = 1 â‰¤ 1 âœ…, left = 3
   *
   *   count += 4 - 3 + 1 = 2
   *   count = 10
   *
   *   Window: 1 0 1 [0 1]
   *                  L R
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * atMost(1) = 10
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * STEP 3: Calculate exactly(2)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * exactly(2) = atMost(2) - atMost(1)
   *            = 14 - 10
   *            = 4 âœ…
   *
   * The 4 subarrays with sum exactly 2:
   * 1. [1, 0, 1]    indices 0-2
   * 2. [1, 0, 1, 0] indices 0-3
   * 3. [0, 1, 0, 1] indices 1-4
   * 4. [1, 0, 1]    indices 2-4
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN 2: nums = [0, 0, 0, 0, 0], goal = 0
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * exactly(0) = atMost(0) - atMost(-1)
   *            = atMost(0) - 0  (atMost returns 0 for k < 0)
   *
   * atMost(0):
   *   All subarrays with sum â‰¤ 0 (only sum = 0 possible)
   *   right=0: count += 1 â†’ count=1
   *   right=1: count += 2 â†’ count=3
   *   right=2: count += 3 â†’ count=6
   *   right=3: count += 4 â†’ count=10
   *   right=4: count += 5 â†’ count=15
   *
   * exactly(0) = 15 - 0 = 15 âœ…
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * WHY O(n)?
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * We call atMost() twice:
   * - atMost(goal): O(n) - each element visited at most twice
   * - atMost(goal-1): O(n) - each element visited at most twice
   *
   * Total: O(n) + O(n) = O(n)
   *
   * In each atMost call:
   * - Right pointer: moves from 0 to n-1 â†’ O(n)
   * - Left pointer: moves from 0 to at most n-1 â†’ O(n)
   * - Each pointer only moves forward, never backward
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * THE COUNTING FORMULA EXPLAINED
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  For valid window [left, right]:                               â”‚
   * â”‚                                                                â”‚
   * â”‚  count += right - left + 1                                     â”‚
   * â”‚                                                                â”‚
   * â”‚  This counts EVERY subarray ending at 'right'!                 â”‚
   * â”‚                                                                â”‚
   * â”‚  Visual:                                                       â”‚
   * â”‚    left=2, right=5: [2, 3, 4, 5]                               â”‚
   * â”‚                                                                â”‚
   * â”‚    Subarrays ending at 5:                                      â”‚
   * â”‚    â”œâ”€â”€ [2,3,4,5] â† starts at left                              â”‚
   * â”‚    â”œâ”€â”€ [3,4,5]                                                 â”‚
   * â”‚    â”œâ”€â”€ [4,5]                                                   â”‚
   * â”‚    â””â”€â”€ [5]       â† starts at right                             â”‚
   * â”‚                                                                â”‚
   * â”‚    Count = 5 - 2 + 1 = 4 âœ…                                    â”‚
   * â”‚                                                                â”‚
   * â”‚  WHY all these are valid?                                      â”‚
   * â”‚  If [left...right] has sum â‰¤ k,                                â”‚
   * â”‚  then any subarray starting AFTER left also has sum â‰¤ k        â”‚
   * â”‚  (because we're removing elements, sum can only decrease)      â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * EDGE CASES
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * 1. goal = 0:
   *    - atMost(-1) returns 0 (handled by k < 0 check)
   *    - exactly(0) = atMost(0) - 0 = atMost(0)
   *
   * 2. All zeros:
   *    - Every subarray has sum = 0
   *    - atMost(0) = n*(n+1)/2 (all possible subarrays)
   *
   * 3. All ones:
   *    - Only subarrays of exactly 'goal' length have sum = goal
   *
   * 4. goal > n:
   *    - Impossible to have sum > n in binary array
   *    - atMost(goal) = n*(n+1)/2 (all subarrays valid)
   *    - atMost(goal-1) = same if goal-1 >= n
   *    - Result = 0 if goal > n
   */

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TEST CASES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  export function runTests(): void {
    console.log("ğŸ§ª Testing Binary Subarrays With Sum - SLIDING WINDOW\n");
    console.log("â•".repeat(60) + "\n");

    const testCases: {
      nums: number[];
      goal: number;
      expected: number;
      description: string;
    }[] = [
      // Examples from problem
      {
        nums: [1, 0, 1, 0, 1],
        goal: 2,
        expected: 4,
        description: "Example 1 - mixed array",
      },
      {
        nums: [0, 0, 0, 0, 0],
        goal: 0,
        expected: 15,
        description: "Example 2 - all zeros, goal=0",
      },

      // Edge cases
      {
        nums: [1],
        goal: 1,
        expected: 1,
        description: "Single element = goal",
      },
      {
        nums: [1],
        goal: 0,
        expected: 0,
        description: "Single element != goal",
      },
      {
        nums: [0],
        goal: 0,
        expected: 1,
        description: "Single zero, goal=0",
      },

      // Goal = 0 cases
      {
        nums: [0, 0, 0],
        goal: 0,
        expected: 6,
        description: "All zeros - n*(n+1)/2 = 6",
      },
      {
        nums: [1, 0, 0, 1],
        goal: 0,
        expected: 3,
        description: "Zeros between ones",
      },

      // All ones
      {
        nums: [1, 1, 1, 1],
        goal: 2,
        expected: 3,
        description: "All ones, goal=2 â†’ 3 pairs",
      },
      {
        nums: [1, 1, 1, 1, 1],
        goal: 3,
        expected: 3,
        description: "All ones, goal=3 â†’ 3 triplets",
      },

      // Trailing zeros matter
      {
        nums: [1, 0, 0, 0],
        goal: 1,
        expected: 4,
        description: "Trailing zeros extend valid subarrays",
      },

      // Leading zeros matter
      {
        nums: [0, 0, 0, 1],
        goal: 1,
        expected: 4,
        description: "Leading zeros create more starting points",
      },

      // Complex case
      {
        nums: [0, 1, 1, 0, 1],
        goal: 2,
        expected: 5,
        description: "Complex mixed case",
      },
    ];

    let passed = 0;
    let failed = 0;

    for (let i = 0; i < testCases.length; i++) {
      const { nums, goal, expected, description } = testCases[i];
      const result = numSubarraysWithSum(nums, goal);
      const status = result === expected ? "âœ… PASS" : "âŒ FAIL";

      if (result === expected) {
        passed++;
      } else {
        failed++;
      }

      console.log(`Test ${i + 1}: ${status}`);
      console.log(`  Description: ${description}`);
      console.log(`  Input: nums = [${nums}], goal = ${goal}`);
      console.log(`  Expected: ${expected}`);
      console.log(`  Got: ${result}`);
      console.log();
    }

    console.log("â•".repeat(60));
    console.log(`\nğŸ“Š Results: ${passed} passed, ${failed} failed\n`);

    if (failed === 0) {
      console.log("ğŸ‰ All tests passed! Sliding Window samajh aa gaya! ğŸš€");
      console.log("ğŸ“Š Complexity: Time O(n), Space O(1)");
      console.log("\nğŸ’¡ Key Trick: exactly(K) = atMost(K) - atMost(K-1)");
      console.log("ğŸ’¡ Counting: For each valid window, count += right - left + 1");
    }
  }
}

// Execute tests
BinarySubarraysWithSumOptimal.runTests();