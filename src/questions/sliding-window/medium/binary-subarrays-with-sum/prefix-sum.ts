/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * BINARY SUBARRAYS WITH SUM - PREFIX SUM + HASHMAP
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Problem: Count number of subarrays with sum exactly equal to goal
 *
 * Key Insight: PREFIX SUM + TWO SUM PATTERN!
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   If prefixSum[j] - prefixSum[i-1] = goal
 *   Then subarray [i...j] has sum = goal
 *
 *   Rearranging: prefixSum[i-1] = prefixSum[j] - goal
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * WHY DOES prefixSum[j] - prefixSum[i] GIVE SUBARRAY SUM?
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚  prefixSum[j] - prefixSum[i] = sum of subarray [i+1 ... j]            â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  WHY? Because subtracting "removes" the prefix portion!                â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   VISUAL PROOF:
 *
 *   Array:      [1,  0,  1,  0,  1]
 *   Index:       0   1   2   3   4
 *
 *   prefixSum[4] = 1 + 0 + 1 + 0 + 1 = 3   (sum of indices 0 to 4)
 *                  â”€   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *                  â†‘        â†‘
 *                Remove   Keep this!
 *
 *   prefixSum[0] = 1                       (sum of index 0 only)
 *                  â”€
 *                  â†‘
 *                This gets subtracted out
 *
 *   prefixSum[4] - prefixSum[0] = 3 - 1 = 2
 *                               = sum of indices 1 to 4
 *                               = [0, 1, 0, 1]
 *                               = 0 + 1 + 0 + 1 = 2 âœ…
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚  Think of it as:                                                       â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  "Total sum tak j" minus "Total sum tak i"                             â”‚
 *   â”‚  = Sum from (i+1) to j                                                 â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  Hinglish: "i tak ka sum hata do, baaki bach jayega!"                  â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   So for each position j:
 *   - Current prefix sum = prefixSum[j]
 *   - We need to find: how many previous positions have prefixSum = current - goal
 *   - HashMap stores: prefixSum â†’ count of occurrences
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * This is similar to "Two Sum" problem!
 * - Two Sum: Find pairs where a + b = target â†’ b = target - a
 * - This: Find subarrays where prefixSum[j] - prefixSum[i] = goal
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * Time Complexity: O(n) - single pass through array
 * Space Complexity: O(n) - HashMap can store up to n+1 unique prefix sums
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

namespace BinarySubarraysWithSumPrefixSum {
  /**
   * Count subarrays with sum exactly equal to goal - PREFIX SUM + HASHMAP
   *
   * @param nums - Binary array (only 0s and 1s)
   * @param goal - Target sum
   * @returns Number of subarrays with sum = goal
   */
  function numSubarraysWithSum(nums: number[], goal: number): number {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HashMap to store: prefixSum â†’ count of occurrences
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const prefixCount: Map<number, number> = new Map();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // IMPORTANT: Initialize with prefixSum 0 having count 1
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // WHY? This handles subarrays starting from index 0!
    //
    // Example: nums = [1, 0, 1], goal = 1
    //   At index 0: prefixSum = 1, need to find prefixSum = 1 - 1 = 0
    //   Without this initialization, we'd miss subarray [1] (index 0)
    //
    // Think of it as: "empty subarray before index 0 has sum 0"
    prefixCount.set(0, 1);

    let count = 0;
    let prefixSum = 0;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAIN LOOP: Process each element
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    for (let i = 0; i < nums.length; i++) {
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 1: Update prefix sum
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      prefixSum += nums[i];

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 2: Find subarrays ending at current index with sum = goal
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  THE KEY INSIGHT:                                          â”‚
      // â”‚                                                            â”‚
      // â”‚  If prefixSum[j] - prefixSum[i-1] = goal                  â”‚
      // â”‚  Then subarray [i...j] has sum = goal                      â”‚
      // â”‚                                                            â”‚
      // â”‚  We need: prefixSum[i-1] = prefixSum[j] - goal            â”‚
      // â”‚                          = current - goal                  â”‚
      // â”‚                          = target                          â”‚
      // â”‚                                                            â”‚
      // â”‚  How many such i-1 positions exist? â†’ prefixCount[target]  â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      const target = prefixSum - goal;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // COUNT CALCULATION - DETAILED EXPLANATION
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  WHAT IS count?                                            â”‚
      // â”‚  â†’ Final answer: TOTAL number of valid subarrays found     â”‚
      // â”‚  â†’ Accumulates across ALL positions                        â”‚
      // â”‚                                                            â”‚
      // â”‚  WHAT IS prefixCount.get(target)?                          â”‚
      // â”‚  â†’ Number of PREVIOUS positions where prefixSum = target   â”‚
      // â”‚  â†’ Each such position gives ONE valid subarray ending here â”‚
      // â”‚                                                            â”‚
      // â”‚  WHY count += prefixCount.get(target)?                     â”‚
      // â”‚  â†’ We're ADDING new subarrays found at current position    â”‚
      // â”‚  â†’ To the subarrays we already found at previous positions â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      //
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // VISUAL EXAMPLE: nums = [1, 0, 1, 0, 1], goal = 2
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // Index:      0    1    2    3    4
      // Array:     [1,   0,   1,   0,   1]
      // prefixSum:  1    1    2    2    3
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  AT INDEX 4: prefixSum = 3, target = 3 - 2 = 1              â”‚
      // â”‚                                                             â”‚
      // â”‚  Question: Kitni baar pehle prefixSum = 1 tha?              â”‚
      // â”‚  Answer: 2 baar! (at index 0 and index 1)                   â”‚
      // â”‚                                                             â”‚
      // â”‚  So prefixCount.get(1) = 2                                  â”‚
      // â”‚                                                             â”‚
      // â”‚  This means: 2 valid subarrays END at index 4               â”‚
      // â”‚                                                             â”‚
      // â”‚  Subarray 1: From after index 0 to index 4                  â”‚
      // â”‚              [0, 1, 0, 1] â†’ sum = 2 âœ…                      â”‚
      // â”‚                                                             â”‚
      // â”‚  Subarray 2: From after index 1 to index 4                  â”‚
      // â”‚              [1, 0, 1] â†’ sum = 2 âœ…                         â”‚
      // â”‚                                                             â”‚
      // â”‚  So we ADD 2 to our count!                                  â”‚
      // â”‚  count = previous_count + 2 = 2 + 2 = 4                     â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      //
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP-BY-STEP COUNT ACCUMULATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // i=0: prefixSum=1, target=-1, not found â†’ count += 0 â†’ count = 0
      // i=1: prefixSum=1, target=-1, not found â†’ count += 0 â†’ count = 0
      // i=2: prefixSum=2, target=0,  found 1x  â†’ count += 1 â†’ count = 1
      //      â†³ Found [1,0,1] (indices 0-2)
      // i=3: prefixSum=2, target=0,  found 1x  â†’ count += 1 â†’ count = 2
      //      â†³ Found [1,0,1,0] (indices 0-3)
      // i=4: prefixSum=3, target=1,  found 2x  â†’ count += 2 â†’ count = 4
      //      â†³ Found [0,1,0,1] (indices 1-4)
      //      â†³ Found [1,0,1] (indices 2-4)
      //
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // KEY INSIGHT: prefixCount tells us "HOW MANY starting points"
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  prefixCount.get(target) = X means:                        â”‚
      // â”‚                                                            â”‚
      // â”‚  "X different positions in the past had prefixSum = target"â”‚
      // â”‚                                                            â”‚
      // â”‚  Each position = One valid starting point for a subarray   â”‚
      // â”‚  All these subarrays END at current position               â”‚
      // â”‚                                                            â”‚
      // â”‚  So we found X new valid subarrays!                        â”‚
      // â”‚  Add all X to our count.                                   â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      // If target exists in map, add its count
      // Each occurrence represents a valid subarray ending at current index
      if (prefixCount.has(target)) {
        count += prefixCount.get(target)!;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 3: Add current prefix sum to map
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // This will help future positions find subarrays ending at them
      prefixCount.set(prefixSum, (prefixCount.get(prefixSum) || 0) + 1);
    }

    return count;
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN - COMPLETE VISUALIZATION
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Example: nums = [1, 0, 1, 0, 1], goal = 2
   *          Index:  0  1  2  3  4
   *
   * Initial: prefixSum = 0, count = 0, prefixCount = {0: 1}
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 0, nums[0] = 1
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixSum = 0 + 1 = 1
   *   target = prefixSum - goal = 1 - 2 = -1
   *
   *   Is -1 in prefixCount? NO
   *   count = 0
   *
   *   Add to map: prefixCount = {0: 1, 1: 1}
   *
   *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   *   â”‚  Visual:                                                    â”‚
   *   â”‚                                                             â”‚
   *   â”‚  Array: [1] 0  1  0  1                                      â”‚
   *   â”‚          â†‘                                                  â”‚
   *   â”‚  prefixSum = 1                                              â”‚
   *   â”‚  Need previous prefixSum = -1 to get subarray sum = 2       â”‚
   *   â”‚  No such position exists â†’ 0 subarrays                      â”‚
   *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 1, nums[1] = 0
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixSum = 1 + 0 = 1
   *   target = 1 - 2 = -1
   *
   *   Is -1 in prefixCount? NO
   *   count = 0
   *
   *   Add to map: prefixCount = {0: 1, 1: 2}  (1 now appears twice!)
   *
   *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   *   â”‚  Note: prefixSum 1 occurred at both index 0 and 1          â”‚
   *   â”‚  This will help us later!                                   â”‚
   *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 2, nums[2] = 1
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixSum = 1 + 1 = 2
   *   target = 2 - 2 = 0
   *
   *   Is 0 in prefixCount? YES! â†’ prefixCount.get(0) = 1
   *   count = 0 + 1 = 1
   *
   *   Add to map: prefixCount = {0: 1, 1: 2, 2: 1}
   *
   *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   *   â”‚  Found 1 subarray ending at index 2:                        â”‚
   *   â”‚                                                             â”‚
   *   â”‚  prefixSum[2] - prefixSum[-1] = 2 - 0 = 2 âœ…                â”‚
   *   â”‚  (prefixSum[-1] = 0 represents "before array starts")       â”‚
   *   â”‚                                                             â”‚
   *   â”‚  Subarray: [1, 0, 1] indices 0-2                            â”‚
   *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 3, nums[3] = 0
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixSum = 2 + 0 = 2
   *   target = 2 - 2 = 0
   *
   *   Is 0 in prefixCount? YES! â†’ prefixCount.get(0) = 1
   *   count = 1 + 1 = 2
   *
   *   Add to map: prefixCount = {0: 1, 1: 2, 2: 2}
   *
   *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   *   â”‚  Found 1 more subarray ending at index 3:                   â”‚
   *   â”‚                                                             â”‚
   *   â”‚  Subarray: [1, 0, 1, 0] indices 0-3                         â”‚
   *   â”‚  Sum = 1 + 0 + 1 + 0 = 2 âœ…                                 â”‚
   *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 4, nums[4] = 1
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixSum = 2 + 1 = 3
   *   target = 3 - 2 = 1
   *
   *   Is 1 in prefixCount? YES! â†’ prefixCount.get(1) = 2
   *   count = 2 + 2 = 4
   *
   *   Add to map: prefixCount = {0: 1, 1: 2, 2: 2, 3: 1}
   *
   *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   *   â”‚  Found 2 more subarrays ending at index 4!                  â”‚
   *   â”‚                                                             â”‚
   *   â”‚  prefixSum 1 occurred at index 0 and index 1:               â”‚
   *   â”‚                                                             â”‚
   *   â”‚  1. prefixSum[4] - prefixSum[0] = 3 - 1 = 2 âœ…              â”‚
   *   â”‚     Subarray: [0, 1, 0, 1] indices 1-4                      â”‚
   *   â”‚                                                             â”‚
   *   â”‚  2. prefixSum[4] - prefixSum[1] = 3 - 1 = 2 âœ…              â”‚
   *   â”‚     Subarray: [1, 0, 1] indices 2-4                         â”‚
   *   â”‚                                                             â”‚
   *   â”‚  Both positions where prefixSum = 1 give valid subarrays!   â”‚
   *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * FINAL RESULT: count = 4
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * The 4 subarrays with sum = 2:
   * 1. [1, 0, 1]    indices 0-2  (found at i=2)
   * 2. [1, 0, 1, 0] indices 0-3  (found at i=3)
   * 3. [0, 1, 0, 1] indices 1-4  (found at i=4)
   * 4. [1, 0, 1]    indices 2-4  (found at i=4)
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN 2: nums = [0, 0, 0, 0, 0], goal = 0
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Initial: prefixCount = {0: 1}
   *
   * i=0: prefixSum=0, target=0-0=0, count += 1 â†’ count=1
   *      prefixCount = {0: 2}
   *
   * i=1: prefixSum=0, target=0, count += 2 â†’ count=3
   *      prefixCount = {0: 3}
   *
   * i=2: prefixSum=0, target=0, count += 3 â†’ count=6
   *      prefixCount = {0: 4}
   *
   * i=3: prefixSum=0, target=0, count += 4 â†’ count=10
   *      prefixCount = {0: 5}
   *
   * i=4: prefixSum=0, target=0, count += 5 â†’ count=15
   *      prefixCount = {0: 6}
   *
   * FINAL: count = 15 âœ… (same as n*(n+1)/2 = 5*6/2 = 15)
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * WHY INITIALIZE prefixCount = {0: 1}?
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  Example: nums = [2], goal = 2 (if not binary)                â”‚
   * â”‚                                                                â”‚
   * â”‚  Without {0: 1}:                                               â”‚
   * â”‚    prefixSum = 2                                               â”‚
   * â”‚    target = 2 - 2 = 0                                          â”‚
   * â”‚    Is 0 in map? NO â†’ count = 0 âŒ WRONG!                       â”‚
   * â”‚                                                                â”‚
   * â”‚  With {0: 1}:                                                  â”‚
   * â”‚    prefixSum = 2                                               â”‚
   * â”‚    target = 0                                                  â”‚
   * â”‚    Is 0 in map? YES â†’ count = 1 âœ… CORRECT!                    â”‚
   * â”‚                                                                â”‚
   * â”‚  The {0: 1} represents "empty prefix before index 0"           â”‚
   * â”‚  This handles subarrays starting from the beginning!           â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * COMPARISON WITH TWO SUM
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  TWO SUM                          â”‚  SUBARRAY SUM                           â”‚
   * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   * â”‚  Find pairs: a + b = target       â”‚  Find subarrays: sum[i..j] = goal       â”‚
   * â”‚  Rewrite: b = target - a          â”‚  Rewrite: prefix[i-1] = prefix[j] - goalâ”‚
   * â”‚  HashMap: value â†’ index           â”‚  HashMap: prefixSum â†’ count             â”‚
   * â”‚  Look for: target - current       â”‚  Look for: prefixSum - goal             â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * WHEN TO USE PREFIX SUM vs SLIDING WINDOW?
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  PREFIX SUM + HASHMAP:                                         â”‚
   * â”‚  âœ… Works for ANY array (positive, negative, zero)             â”‚
   * â”‚  âœ… Simpler to understand                                      â”‚
   * â”‚  âŒ Uses O(n) extra space                                      â”‚
   * â”‚                                                                â”‚
   * â”‚  SLIDING WINDOW (AT MOST TRICK):                               â”‚
   * â”‚  âœ… O(1) space                                                 â”‚
   * â”‚  âœ… Slightly faster (no hash operations)                       â”‚
   * â”‚  âŒ Only works for non-negative arrays                         â”‚
   * â”‚  âŒ Trickier to implement correctly                            â”‚
   * â”‚                                                                â”‚
   * â”‚  For binary arrays: Both work, sliding window is more optimal  â”‚
   * â”‚  For arrays with negatives: Must use prefix sum approach       â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * EDGE CASES
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * 1. goal = 0: Works naturally - looking for prefixSum = current - 0 = current
   * 2. All zeros: prefixSum stays 0, count accumulates 1+2+3+...+n
   * 3. Single element: Handled by {0: 1} initialization
   * 4. goal > sum of array: target will always be negative, no matches
   */

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TEST CASES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  export function runTests(): void {
    console.log(
      'ğŸ§ª Testing Binary Subarrays With Sum - PREFIX SUM + HASHMAP\n'
    );
    console.log('â•'.repeat(60) + '\n');

    const testCases: {
      nums: number[];
      goal: number;
      expected: number;
      description: string;
    }[] = [
      // Examples from problem
      {
        nums: [1, 0, 1, 0, 1],
        goal: 2,
        expected: 4,
        description: 'Example 1 - mixed array',
      },
      {
        nums: [0, 0, 0, 0, 0],
        goal: 0,
        expected: 15,
        description: 'Example 2 - all zeros, goal=0',
      },

      // Edge cases
      {
        nums: [1],
        goal: 1,
        expected: 1,
        description: 'Single element = goal',
      },
      {
        nums: [1],
        goal: 0,
        expected: 0,
        description: 'Single element != goal',
      },
      {
        nums: [0],
        goal: 0,
        expected: 1,
        description: 'Single zero, goal=0',
      },

      // Goal = 0 cases
      {
        nums: [0, 0, 0],
        goal: 0,
        expected: 6,
        description: 'All zeros - n*(n+1)/2 = 6',
      },
      {
        nums: [1, 0, 0, 1],
        goal: 0,
        expected: 3,
        description: 'Zeros between ones',
      },

      // All ones
      {
        nums: [1, 1, 1, 1],
        goal: 2,
        expected: 3,
        description: 'All ones, goal=2 â†’ 3 pairs',
      },
      {
        nums: [1, 1, 1, 1, 1],
        goal: 3,
        expected: 3,
        description: 'All ones, goal=3 â†’ 3 triplets',
      },

      // Trailing zeros matter
      {
        nums: [1, 0, 0, 0],
        goal: 1,
        expected: 4,
        description: 'Trailing zeros extend valid subarrays',
      },

      // Leading zeros matter
      {
        nums: [0, 0, 0, 1],
        goal: 1,
        expected: 4,
        description: 'Leading zeros create more starting points',
      },

      // Complex case
      {
        nums: [0, 1, 1, 0, 1],
        goal: 2,
        expected: 5,
        description: 'Complex mixed case',
      },
    ];

    let passed = 0;
    let failed = 0;

    for (let i = 0; i < testCases.length; i++) {
      const { nums, goal, expected, description } = testCases[i];
      const result = numSubarraysWithSum(nums, goal);
      const status = result === expected ? 'âœ… PASS' : 'âŒ FAIL';

      if (result === expected) {
        passed++;
      } else {
        failed++;
      }

      console.log(`Test ${i + 1}: ${status}`);
      console.log(`  Description: ${description}`);
      console.log(`  Input: nums = [${nums}], goal = ${goal}`);
      console.log(`  Expected: ${expected}`);
      console.log(`  Got: ${result}`);
      console.log();
    }

    console.log('â•'.repeat(60));
    console.log(`\nğŸ“Š Results: ${passed} passed, ${failed} failed\n`);

    if (failed === 0) {
      console.log('ğŸ‰ All tests passed! Prefix Sum samajh aa gaya! ğŸš€');
      console.log('ğŸ“Š Complexity: Time O(n), Space O(n)');
      console.log('\nğŸ’¡ Key Insight: prefixSum[j] - prefixSum[i-1] = goal');
      console.log(
        'ğŸ’¡ Similar to Two Sum: Look for (current - goal) in HashMap'
      );
    }
  }
}

// Execute tests
BinarySubarraysWithSumPrefixSum.runTests();