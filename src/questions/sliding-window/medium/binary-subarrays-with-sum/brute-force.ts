/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * BINARY SUBARRAYS WITH SUM - BRUTE FORCE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Problem: Count number of subarrays with sum exactly equal to goal
 *          (Binary array - only 0s and 1s)
 *
 * Key Insight: COUNTING problem, not FINDING longest/shortest
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   Unlike previous sliding window problems:
 *   - We need to COUNT subarrays, not find max length
 *   - We need EXACTLY goal, not "at most" goal
 *
 *   This makes it a different type of problem!
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * Approach: Brute Force - Check ALL possible subarrays
 * - For each starting position i
 * - Try all ending positions j (from i to end)
 * - Track running sum
 * - If sum == goal, increment count
 * - If sum > goal, break (optimization for binary array)
 *
 * Time Complexity: O(nÂ²) - nested loops
 * Space Complexity: O(1) - only using variables
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

namespace BinarySubarraysWithSumBruteForce {
  /**
   * Count subarrays with sum exactly equal to goal - BRUTE FORCE
   *
   * @param nums - Binary array (only 0s and 1s)
   * @param goal - Target sum
   * @returns Number of subarrays with sum = goal
   */
  function numSubarraysWithSum(nums: number[], goal: number): number {
    let count = 0;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // OUTER LOOP: Try each starting position
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    for (let i = 0; i < nums.length; i++) {
      // Track running sum for current starting position
      // Reset for each new starting position
      let sum = 0;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // INNER LOOP: Try each ending position
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      for (let j = i; j < nums.length; j++) {
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // STEP 1: Add current element to sum
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        sum += nums[j];

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // STEP 2: Check if sum equals goal
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (sum === goal) {
          // Found a valid subarray! Increment count
          count++;
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // STEP 3: Optimization - Break if sum exceeds goal
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        //
        // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        // â”‚  WHY CAN WE BREAK?                                         â”‚
        // â”‚                                                            â”‚
        // â”‚  This is a BINARY array (only 0s and 1s)!                  â”‚
        // â”‚                                                            â”‚
        // â”‚  If sum > goal:                                            â”‚
        // â”‚  - Adding more elements can only ADD 0 or 1                â”‚
        // â”‚  - Sum can only INCREASE or STAY SAME                      â”‚
        // â”‚  - It can NEVER decrease back to goal!                     â”‚
        // â”‚                                                            â”‚
        // â”‚  So we can safely break and try next starting position.    â”‚
        // â”‚                                                            â”‚
        // â”‚  NOTE: This works for binary arrays only!                  â”‚
        // â”‚        For arrays with negative numbers, can't break.      â”‚
        // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        //
        // IMPORTANT: We do NOT break when sum === goal!
        // WHY? Because there might be zeros ahead!
        //
        // Example: nums = [1,0,0,1], goal = 1
        //   i=0, j=0: sum=1 âœ… count++
        //   i=0, j=1: sum=1 âœ… count++ (added 0, sum unchanged!)
        //   i=0, j=2: sum=1 âœ… count++ (added 0, sum unchanged!)
        //   i=0, j=3: sum=2 > 1, NOW break
        //
        // The zeros let us extend the subarray while keeping sum = goal!

        if (sum > goal) {
          break;
        }
      }
    }

    return count;
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN - COMPLETE VISUALIZATION
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Example 1: nums = [1, 0, 1, 0, 1], goal = 2
   *            Index:  0  1  2  3  4
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 0 (Start from index 0)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * j=0: sum = 0 + 1 = 1, sum != 2, continue
   *      Subarray: [1]
   *
   * j=1: sum = 1 + 0 = 1, sum != 2, continue
   *      Subarray: [1, 0]
   *
   * j=2: sum = 1 + 1 = 2, sum == 2 âœ… count = 1
   *      Subarray: [1, 0, 1] â† Found!
   *
   * j=3: sum = 2 + 0 = 2, sum == 2 âœ… count = 2
   *      Subarray: [1, 0, 1, 0] â† Found! (trailing 0 doesn't change sum)
   *
   * j=4: sum = 2 + 1 = 3, sum > 2, BREAK!
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 1 (Start from index 1)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * j=1: sum = 0, sum != 2, continue
   *      Subarray: [0]
   *
   * j=2: sum = 0 + 1 = 1, sum != 2, continue
   *      Subarray: [0, 1]
   *
   * j=3: sum = 1 + 0 = 1, sum != 2, continue
   *      Subarray: [0, 1, 0]
   *
   * j=4: sum = 1 + 1 = 2, sum == 2 âœ… count = 3
   *      Subarray: [0, 1, 0, 1] â† Found!
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 2 (Start from index 2)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * j=2: sum = 1, sum != 2, continue
   *      Subarray: [1]
   *
   * j=3: sum = 1 + 0 = 1, sum != 2, continue
   *      Subarray: [1, 0]
   *
   * j=4: sum = 1 + 1 = 2, sum == 2 âœ… count = 4
   *      Subarray: [1, 0, 1] â† Found!
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 3 (Start from index 3)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * j=3: sum = 0, sum != 2, continue
   * j=4: sum = 0 + 1 = 1, sum != 2, continue
   * (end of array)
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 4 (Start from index 4)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * j=4: sum = 1, sum != 2, continue
   * (end of array)
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * FINAL RESULT: count = 4
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * The 4 subarrays with sum = 2:
   * 1. [1, 0, 1]    indices 0-2
   * 2. [1, 0, 1, 0] indices 0-3
   * 3. [0, 1, 0, 1] indices 1-4
   * 4. [1, 0, 1]    indices 2-4
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN 2: nums = [0, 0, 0, 0, 0], goal = 0
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Every subarray has sum = 0!
   *
   * i=0: j=0,1,2,3,4 â†’ all have sum=0 âœ… â†’ 5 subarrays
   * i=1: j=1,2,3,4   â†’ all have sum=0 âœ… â†’ 4 subarrays
   * i=2: j=2,3,4     â†’ all have sum=0 âœ… â†’ 3 subarrays
   * i=3: j=3,4       â†’ all have sum=0 âœ… â†’ 2 subarrays
   * i=4: j=4         â†’ sum=0 âœ… â†’ 1 subarray
   *
   * Total = 5 + 4 + 3 + 2 + 1 = 15 subarrays
   *
   * Formula: n*(n+1)/2 = 5*6/2 = 15 âœ…
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * WHY O(nÂ²)?
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Outer loop: n starting positions           â†’ O(n)
   * Inner loop: up to n ending positions each  â†’ O(n)
   *                                            â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * Total:                                       O(nÂ²)
   *
   * The break optimization helps in practice but worst case
   * (like all zeros with goal=0) still requires checking all pairs.
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * IMPORTANT: Why NOT break on sum === goal?
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  WRONG: break when sum === goal                               â”‚
   * â”‚                                                                â”‚
   * â”‚  nums = [1, 0, 0, 1], goal = 1                                 â”‚
   * â”‚                                                                â”‚
   * â”‚  i=0:                                                          â”‚
   * â”‚    j=0: sum=1 âœ… count++ (WRONG: if we break here...)          â”‚
   * â”‚    j=1: sum=1 âœ… count++ (we miss this!)                       â”‚
   * â”‚    j=2: sum=1 âœ… count++ (and this!)                           â”‚
   * â”‚    j=3: sum=2 > 1, break                                       â”‚
   * â”‚                                                                â”‚
   * â”‚  Zeros don't change sum! So same sum continues.               â”‚
   * â”‚  Only break when sum EXCEEDS goal.                            â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * EDGE CASES
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * 1. goal = 0, all zeros: Every subarray is valid
   * 2. goal = 0, has 1s: Only subarrays with all zeros are valid
   * 3. goal > n: Impossible, return 0
   * 4. Single element: Check if nums[0] === goal
   * 5. All ones: Only subarrays of length = goal are valid
   */

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TEST CASES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  export function runTests(): void {
    console.log("ğŸ§ª Testing Binary Subarrays With Sum - BRUTE FORCE\n");
    console.log("â•".repeat(60) + "\n");

    const testCases: {
      nums: number[];
      goal: number;
      expected: number;
      description: string;
    }[] = [
      // Examples from problem
      {
        nums: [1, 0, 1, 0, 1],
        goal: 2,
        expected: 4,
        description: "Example 1 - mixed array",
      },
      {
        nums: [0, 0, 0, 0, 0],
        goal: 0,
        expected: 15,
        description: "Example 2 - all zeros, goal=0",
      },

      // Edge cases
      {
        nums: [1],
        goal: 1,
        expected: 1,
        description: "Single element = goal",
      },
      {
        nums: [1],
        goal: 0,
        expected: 0,
        description: "Single element != goal",
      },
      {
        nums: [0],
        goal: 0,
        expected: 1,
        description: "Single zero, goal=0",
      },

      // Goal = 0 cases
      {
        nums: [0, 0, 0],
        goal: 0,
        expected: 6,
        description: "All zeros - n*(n+1)/2 = 6",
      },
      {
        nums: [1, 0, 0, 1],
        goal: 0,
        expected: 3,
        description: "Zeros between ones",
      },

      // All ones
      {
        nums: [1, 1, 1, 1],
        goal: 2,
        expected: 3,
        description: "All ones, goal=2 â†’ 3 pairs",
      },
      {
        nums: [1, 1, 1, 1, 1],
        goal: 3,
        expected: 3,
        description: "All ones, goal=3 â†’ 3 triplets",
      },

      // Trailing zeros matter
      {
        nums: [1, 0, 0, 0],
        goal: 1,
        expected: 4,
        description: "Trailing zeros extend valid subarrays",
      },

      // Leading zeros matter
      {
        nums: [0, 0, 0, 1],
        goal: 1,
        expected: 4,
        description: "Leading zeros create more starting points",
      },

      // Complex case
      {
        nums: [0, 1, 1, 0, 1],
        goal: 2,
        expected: 5,
        description: "Complex mixed case",
      },
    ];

    let passed = 0;
    let failed = 0;

    for (let i = 0; i < testCases.length; i++) {
      const { nums, goal, expected, description } = testCases[i];
      const result = numSubarraysWithSum(nums, goal);
      const status = result === expected ? "âœ… PASS" : "âŒ FAIL";

      if (result === expected) {
        passed++;
      } else {
        failed++;
      }

      console.log(`Test ${i + 1}: ${status}`);
      console.log(`  Description: ${description}`);
      console.log(`  Input: nums = [${nums}], goal = ${goal}`);
      console.log(`  Expected: ${expected}`);
      console.log(`  Got: ${result}`);
      console.log();
    }

    console.log("â•".repeat(60));
    console.log(`\nğŸ“Š Results: ${passed} passed, ${failed} failed\n`);

    if (failed === 0) {
      console.log("ğŸ‰ All tests passed! Brute Force samajh aa gaya! ğŸš€");
      console.log("ğŸ“Š Complexity: Time O(nÂ²), Space O(1)");
      console.log("\nğŸ’¡ Key Insight: Don't break on sum === goal (zeros ahead!)");
      console.log("âš ï¸  Note: Sliding Window is O(n) - more optimal!");
    }
  }
}

// Execute tests
BinarySubarraysWithSumBruteForce.runTests();