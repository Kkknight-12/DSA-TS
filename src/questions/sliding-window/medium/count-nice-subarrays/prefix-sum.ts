/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * COUNT NUMBER OF NICE SUBARRAYS - PREFIX SUM + HASHMAP
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Problem: Count subarrays with exactly k odd numbers
 *
 * Key Insight: SAME AS BINARY SUBARRAYS WITH SUM!
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚  TRANSFORMATION:                                                       â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  Odd number  â†’ treat as 1                                              â”‚
 *   â”‚  Even number â†’ treat as 0                                              â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  Instead of tracking "sum", track "count of odd numbers so far"        â”‚
 *   â”‚  This is essentially a "prefix odd count"                              â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * WHY DOES prefixOddCount[j] - prefixOddCount[i] WORK?
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚  prefixOddCount[j] - prefixOddCount[i] = odd numbers in subarray [i+1..j]â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  WHY? Because subtracting "removes" the prefix portion!                â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   VISUAL PROOF:
 *
 *   Array:           [2,  2,  2,  1,  2,  2,  1,  2,  2,  2]
 *   Index:            0   1   2   3   4   5   6   7   8   9
 *   Is Odd?:          0   0   0   1   0   0   1   0   0   0
 *   prefixOddCount:   0   0   0   1   1   1   2   2   2   2
 *
 *   prefixOddCount[6] = 2 (odd numbers from index 0 to 6)
 *   prefixOddCount[2] = 0 (odd numbers from index 0 to 2)
 *
 *   prefixOddCount[6] - prefixOddCount[2] = 2 - 0 = 2
 *                                         = odd numbers in indices 3 to 6
 *                                         = [1, 2, 2, 1] has 2 odd numbers âœ…
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚  Think of it as:                                                       â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  "Total odd count tak j" minus "Total odd count tak i"                 â”‚
 *   â”‚  = Odd count from (i+1) to j                                           â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  Hinglish: "i tak ke odds hata do, baaki bach jayenge!"                â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * THE TWO SUM PATTERN
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   If prefixOddCount[j] - prefixOddCount[i-1] = k
 *   Then subarray [i...j] has exactly k odd numbers
 *
 *   Rearranging: prefixOddCount[i-1] = prefixOddCount[j] - k
 *                                    = current - k
 *                                    = target
 *
 *   So for each position j:
 *   - Current prefix odd count = prefixOddCount[j]
 *   - We need to find: how many previous positions have prefixOddCount = current - k
 *   - HashMap stores: prefixOddCount â†’ count of occurrences
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * Time Complexity: O(n) - single pass through array
 * Space Complexity: O(n) - HashMap can store up to n+1 unique prefix counts
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

namespace CountNiceSubarraysPrefixSum {
  /**
   * Count nice subarrays (subarrays with exactly k odd numbers) - PREFIX SUM + HASHMAP
   *
   * @param nums - Array of integers
   * @param k - Target number of odd numbers
   * @returns Number of nice subarrays
   */
  function numberOfSubarrays(nums: number[], k: number): number {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HashMap to store: prefixOddCount â†’ count of occurrences
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const prefixCount: Map<number, number> = new Map();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // IMPORTANT: Initialize with prefixOddCount 0 having count 1
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // WHY? This handles subarrays starting from index 0!
    //
    // Example: nums = [1, 2, 3], k = 1
    //   At index 0: prefixOddCount = 1, need to find prefixOddCount = 1 - 1 = 0
    //   Without this initialization, we'd miss subarray [1] (index 0)
    //
    // Think of it as: "before index 0, we've seen 0 odd numbers"
    prefixCount.set(0, 1);

    let count = 0;
    let prefixOddCount = 0; // Running count of odd numbers

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAIN LOOP: Process each element
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    for (let i = 0; i < nums.length; i++) {
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 1: Update prefix odd count
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // nums[i] % 2 gives: 1 if odd, 0 if even
      // So prefixOddCount increases by 1 for odd, 0 for even
      prefixOddCount += nums[i] % 2;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 2: Find subarrays ending at current index with k odd numbers
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  THE KEY INSIGHT:                                          â”‚
      // â”‚                                                            â”‚
      // â”‚  If prefixOddCount[j] - prefixOddCount[i-1] = k            â”‚
      // â”‚  Then subarray [i...j] has exactly k odd numbers           â”‚
      // â”‚                                                            â”‚
      // â”‚  We need: prefixOddCount[i-1] = prefixOddCount[j] - k      â”‚
      // â”‚                               = current - k                â”‚
      // â”‚                               = target                     â”‚
      // â”‚                                                            â”‚
      // â”‚  How many such i-1 positions exist? â†’ prefixCount[target]  â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      const target = prefixOddCount - k;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // COUNT CALCULATION
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  WHAT IS count?                                            â”‚
      // â”‚  â†’ Final answer: TOTAL number of valid subarrays found     â”‚
      // â”‚  â†’ Accumulates across ALL positions                        â”‚
      // â”‚                                                            â”‚
      // â”‚  WHAT IS prefixCount.get(target)?                          â”‚
      // â”‚  â†’ Number of PREVIOUS positions where prefixOddCount=targetâ”‚
      // â”‚  â†’ Each such position gives ONE valid subarray ending here â”‚
      // â”‚                                                            â”‚
      // â”‚  WHY count += prefixCount.get(target)?                     â”‚
      // â”‚  â†’ We're ADDING new subarrays found at current position    â”‚
      // â”‚  â†’ To the subarrays we already found at previous positions â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      // If target exists in map, add its count
      // Each occurrence represents a valid subarray ending at current index
      if (prefixCount.has(target)) {
        count += prefixCount.get(target)!;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 3: Add current prefix odd count to map
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // This will help future positions find subarrays ending at them
      prefixCount.set(
        prefixOddCount,
        (prefixCount.get(prefixOddCount) || 0) + 1
      );
    }

    return count;
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN - COMPLETE VISUALIZATION
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Example: nums = [1, 1, 2, 1, 1], k = 3
   *          Index:  0  1  2  3  4
   *          Odd?:   âœ“  âœ“  âœ—  âœ“  âœ“
   *
   * Initial: prefixOddCount = 0, count = 0, prefixCount = {0: 1}
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 0, nums[0] = 1 (odd)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixOddCount = 0 + 1 = 1
   *   target = 1 - 3 = -2
   *
   *   Is -2 in prefixCount? NO
   *   count = 0
   *
   *   Add to map: prefixCount = {0: 1, 1: 1}
   *
   *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   *   â”‚  We need previous prefixOddCount = -2 to have k=3 odds     â”‚
   *   â”‚  Impossible! Can't have negative odd count.                â”‚
   *   â”‚  No valid subarrays ending at index 0.                     â”‚
   *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 1, nums[1] = 1 (odd)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixOddCount = 1 + 1 = 2
   *   target = 2 - 3 = -1
   *
   *   Is -1 in prefixCount? NO
   *   count = 0
   *
   *   Add to map: prefixCount = {0: 1, 1: 1, 2: 1}
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 2, nums[2] = 2 (even)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixOddCount = 2 + 0 = 2  (even adds 0)
   *   target = 2 - 3 = -1
   *
   *   Is -1 in prefixCount? NO
   *   count = 0
   *
   *   Add to map: prefixCount = {0: 1, 1: 1, 2: 2}  (2 appears twice!)
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 3, nums[3] = 1 (odd)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixOddCount = 2 + 1 = 3
   *   target = 3 - 3 = 0
   *
   *   Is 0 in prefixCount? YES! â†’ prefixCount.get(0) = 1
   *   count = 0 + 1 = 1
   *
   *   Add to map: prefixCount = {0: 1, 1: 1, 2: 2, 3: 1}
   *
   *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   *   â”‚  Found 1 subarray ending at index 3:                        â”‚
   *   â”‚                                                             â”‚
   *   â”‚  prefixOddCount[3] - prefixOddCount[-1] = 3 - 0 = 3 âœ…      â”‚
   *   â”‚  (prefixOddCount[-1] = 0 represents "before array starts") â”‚
   *   â”‚                                                             â”‚
   *   â”‚  Subarray: [1, 1, 2, 1] indices 0-3, has 3 odd numbers      â”‚
   *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * i = 4, nums[4] = 1 (odd)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   *   prefixOddCount = 3 + 1 = 4
   *   target = 4 - 3 = 1
   *
   *   Is 1 in prefixCount? YES! â†’ prefixCount.get(1) = 1
   *   count = 1 + 1 = 2
   *
   *   Add to map: prefixCount = {0: 1, 1: 1, 2: 2, 3: 1, 4: 1}
   *
   *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   *   â”‚  Found 1 subarray ending at index 4:                        â”‚
   *   â”‚                                                             â”‚
   *   â”‚  prefixOddCount[4] - prefixOddCount[0] = 4 - 1 = 3 âœ…      â”‚
   *   â”‚                                                             â”‚
   *   â”‚  Subarray: [1, 2, 1, 1] indices 1-4, has 3 odd numbers      â”‚
   *   â”‚  (Starting AFTER index 0, so from index 1)                  â”‚
   *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * FINAL RESULT: count = 2
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * The 2 nice subarrays with 3 odd numbers:
   * 1. [1, 1, 2, 1] indices 0-3 (found at i=3)
   * 2. [1, 2, 1, 1] indices 1-4 (found at i=4)
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN 2: nums = [2, 2, 2, 1, 2, 2, 1, 2, 2, 2], k = 2
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Index:          0  1  2  3  4  5  6  7  8  9
   * Odd?:           âœ—  âœ—  âœ—  âœ“  âœ—  âœ—  âœ“  âœ—  âœ—  âœ—
   * prefixOddCount: 0  0  0  1  1  1  2  2  2  2
   *
   * Initial: prefixCount = {0: 1}
   *
   * i=0: odd=0, target=-2, not found, prefixCount={0:2}
   * i=1: odd=0, target=-2, not found, prefixCount={0:3}
   * i=2: odd=0, target=-2, not found, prefixCount={0:4}
   * i=3: odd=1, target=-1, not found, prefixCount={0:4, 1:1}
   * i=4: odd=1, target=-1, not found, prefixCount={0:4, 1:2}
   * i=5: odd=1, target=-1, not found, prefixCount={0:4, 1:3}
   * i=6: odd=2, target=0, found 4x! count=4, prefixCount={0:4, 1:3, 2:1}
   * i=7: odd=2, target=0, found 4x! count=8, prefixCount={0:4, 1:3, 2:2}
   * i=8: odd=2, target=0, found 4x! count=12, prefixCount={0:4, 1:3, 2:3}
   * i=9: odd=2, target=0, found 4x! count=16, prefixCount={0:4, 1:3, 2:4}
   *
   * FINAL: count = 16 âœ…
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  WHY count += 4 at index 6?                                    â”‚
   * â”‚                                                                â”‚
   * â”‚  prefixOddCount[6] = 2, target = 2 - 2 = 0                     â”‚
   * â”‚  prefixCount[0] = 4 (indices -1, 0, 1, 2 all had oddCount=0)   â”‚
   * â”‚                                                                â”‚
   * â”‚  4 subarrays ending at index 6:                                â”‚
   * â”‚  - [2,2,2,1,2,2,1] starting at 0                               â”‚
   * â”‚  - [2,2,1,2,2,1] starting at 1                                 â”‚
   * â”‚  - [2,1,2,2,1] starting at 2                                   â”‚
   * â”‚  - [1,2,2,1] starting at 3                                     â”‚
   * â”‚                                                                â”‚
   * â”‚  All have exactly 2 odd numbers! âœ…                            â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * WHY INITIALIZE prefixCount = {0: 1}?
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  Example: nums = [1, 3], k = 2 (both are odd)                  â”‚
   * â”‚                                                                â”‚
   * â”‚  Without {0: 1}:                                               â”‚
   * â”‚    prefixOddCount = 2                                          â”‚
   * â”‚    target = 2 - 2 = 0                                          â”‚
   * â”‚    Is 0 in map? NO â†’ count = 0 âŒ WRONG!                       â”‚
   * â”‚                                                                â”‚
   * â”‚  With {0: 1}:                                                  â”‚
   * â”‚    prefixOddCount = 2                                          â”‚
   * â”‚    target = 0                                                  â”‚
   * â”‚    Is 0 in map? YES â†’ count = 1 âœ… CORRECT!                    â”‚
   * â”‚                                                                â”‚
   * â”‚  The {0: 1} represents "empty prefix before index 0"           â”‚
   * â”‚  This handles subarrays starting from the beginning!           â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * COMPARISON: SLIDING WINDOW vs PREFIX SUM
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  SLIDING WINDOW (AT MOST K):                                   â”‚
   * â”‚  âœ… O(1) space                                                 â”‚
   * â”‚  âœ… Slightly faster (no hash operations)                       â”‚
   * â”‚  âŒ Only works for non-negative "counts"                       â”‚
   * â”‚  âŒ Requires the atMost trick (trickier)                       â”‚
   * â”‚                                                                â”‚
   * â”‚  PREFIX SUM + HASHMAP:                                         â”‚
   * â”‚  âœ… Simpler to understand (direct counting)                    â”‚
   * â”‚  âœ… Works for ANY array (positive, negative, zero)             â”‚
   * â”‚  âŒ Uses O(n) extra space                                      â”‚
   * â”‚                                                                â”‚
   * â”‚  For this problem: Both work well!                             â”‚
   * â”‚  Sliding window is slightly more optimal (O(1) space)          â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * COMPARISON WITH BINARY SUBARRAYS WITH SUM
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  Binary Subarrays:              Nice Subarrays:                            â”‚
   * â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
   * â”‚  prefixSum += nums[i]           prefixOddCount += nums[i] % 2              â”‚
   * â”‚  target = prefixSum - goal      target = prefixOddCount - k                â”‚
   * â”‚                                                                             â”‚
   * â”‚  LITERALLY THE SAME ALGORITHM!                                              â”‚
   * â”‚  Just different way of "accumulating 1s"                                    â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TEST CASES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  export function runTests(): void {
    console.log('ğŸ§ª Testing Count Nice Subarrays - PREFIX SUM + HASHMAP\n');
    console.log('â•'.repeat(60) + '\n');

    const testCases: {
      nums: number[];
      k: number;
      expected: number;
      description: string;
    }[] = [
      // Examples from problem
      {
        nums: [1, 1, 2, 1, 1],
        k: 3,
        expected: 2,
        description: 'Example 1 - basic case',
      },
      {
        nums: [2, 4, 6],
        k: 1,
        expected: 0,
        description: 'Example 2 - all even numbers',
      },
      {
        nums: [2, 2, 2, 1, 2, 2, 1, 2, 2, 2],
        k: 2,
        expected: 16,
        description: 'Example 3 - evens padding both sides',
      },

      // Edge cases
      {
        nums: [1],
        k: 1,
        expected: 1,
        description: 'Single odd element',
      },
      {
        nums: [2],
        k: 1,
        expected: 0,
        description: 'Single even element',
      },
      {
        nums: [1, 1, 1],
        k: 1,
        expected: 3,
        description: 'All odd, k=1',
      },
      {
        nums: [1, 1, 1],
        k: 2,
        expected: 2,
        description: 'All odd, k=2',
      },
      {
        nums: [1, 1, 1],
        k: 3,
        expected: 1,
        description: 'All odd, k=3',
      },

      // Even numbers extending
      {
        nums: [2, 1, 2],
        k: 1,
        expected: 4,
        description: 'One odd with even padding (2Ã—2=4)',
      },
      {
        nums: [2, 2, 1, 2, 2],
        k: 1,
        expected: 9,
        description: 'One odd, many evens (3Ã—3=9)',
      },

      // Mixed cases
      {
        nums: [1, 2, 1, 2, 1],
        k: 2,
        expected: 4,
        description: 'Alternating odd-even',
      },
      {
        nums: [2, 1, 2, 1, 2],
        k: 2,
        expected: 4,
        description: 'Evens around two odds',
      },
    ];

    let passed = 0;
    let failed = 0;

    for (let i = 0; i < testCases.length; i++) {
      const { nums, k, expected, description } = testCases[i];
      const result = numberOfSubarrays(nums, k);
      const status = result === expected ? 'âœ… PASS' : 'âŒ FAIL';

      if (result === expected) {
        passed++;
      } else {
        failed++;
      }

      console.log(`Test ${i + 1}: ${status}`);
      console.log(`  Description: ${description}`);
      console.log(`  Input: nums = [${nums}], k = ${k}`);
      console.log(`  Expected: ${expected}`);
      console.log(`  Got: ${result}`);
      console.log();
    }

    console.log('â•'.repeat(60));
    console.log(`\nğŸ“Š Results: ${passed} passed, ${failed} failed\n`);

    if (failed === 0) {
      console.log('ğŸ‰ All tests passed! Prefix Sum samajh aa gaya! ğŸš€');
      console.log('ğŸ“Š Complexity: Time O(n), Space O(n)');
      console.log(
        '\nğŸ’¡ Key Insight: prefixOddCount[j] - prefixOddCount[i-1] = k'
      );
      console.log('ğŸ’¡ Same Two Sum pattern as Binary Subarrays With Sum!');
    }
  }
}

// Execute tests
CountNiceSubarraysPrefixSum.runTests();