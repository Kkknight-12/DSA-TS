/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * COUNT NUMBER OF NICE SUBARRAYS - SLIDING WINDOW (AT MOST K TRICK)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Problem: Count subarrays with exactly k odd numbers
 *
 * Key Insight: SAME AS BINARY SUBARRAYS WITH SUM!
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚  TRANSFORMATION:                                                       â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  Odd number  â†’ treat as 1                                              â”‚
 *   â”‚  Even number â†’ treat as 0                                              â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  "Count subarrays with exactly k odd numbers"                          â”‚
 *   â”‚  = "Count subarrays with sum = k" (in binary form)                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * THE "AT MOST K" TRICK
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚                                                                        â”‚
 *   â”‚  exactly(k) = atMost(k) - atMost(k-1)                                  â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  Subarrays with EXACTLY k odd numbers =                                â”‚
 *   â”‚    Subarrays with AT MOST k odd numbers                                â”‚
 *   â”‚  - Subarrays with AT MOST (k-1) odd numbers                            â”‚
 *   â”‚                                                                        â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   WHY THIS WORKS?
 *
 *   atMost(k) includes: 0, 1, 2, ..., k odd numbers
 *   atMost(k-1) includes: 0, 1, 2, ..., k-1 odd numbers
 *
 *   Subtracting removes 0 to k-1, leaving ONLY exactly k!
 *
 *   Visual:
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚  atMost(k):   [0] [1] [2] ... [k-1] [k]                                â”‚
 *   â”‚  atMost(k-1): [0] [1] [2] ... [k-1]                                    â”‚
 *   â”‚               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                    â”‚
 *   â”‚               These cancel out!                                        â”‚
 *   â”‚                                                                        â”‚
 *   â”‚  Result:                          [k]  â† Only exactly k remains!       â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * Time Complexity: O(n) - each element visited at most twice
 * Space Complexity: O(1) - only using variables
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

namespace CountNiceSubarraysOptimal {
  /**
   * Count nice subarrays (subarrays with exactly k odd numbers) - SLIDING WINDOW
   *
   * @param nums - Array of integers
   * @param k - Target number of odd numbers
   * @returns Number of nice subarrays
   */
  function numberOfSubarrays(nums: number[], k: number): number {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THE MAGIC FORMULA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //
    // exactly(k) = atMost(k) - atMost(k-1)

    return atMost(nums, k) - atMost(nums, k - 1);
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * HELPER: Count subarrays with AT MOST k odd numbers
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * This is the standard sliding window for "at most" problems.
   *
   * Key insight: For each valid window ending at 'right',
   * count ALL subarrays ending at 'right' = (right - left + 1)
   */
  function atMost(nums: number[], k: number): number {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // EDGE CASE: k < 0
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // If k is negative, no subarray can have negative odd numbers
    // This happens when we call atMost(k-1) with k=0
    if (k < 0) return 0;

    let count = 0;
    let oddCount = 0; // Number of odd numbers in current window
    let left = 0;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SLIDING WINDOW: Expand right pointer
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    for (let right = 0; right < nums.length; right++) {
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 1: Add current element to window
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // If odd, increment oddCount
      // nums[right] % 2 gives: 1 if odd, 0 if even
      oddCount += nums[right] % 2;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 2: Shrink window if oddCount exceeds k
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  WHY WHILE AND NOT IF?                                     â”‚
      // â”‚                                                            â”‚
      // â”‚  In this problem, each element adds at most 1 to oddCount  â”‚
      // â”‚  So 'if' would work too. But 'while' is the general        â”‚
      // â”‚  pattern for sliding window - safer and more universal.    â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      while (oddCount > k) {
        // Remove left element from window
        // If it was odd, decrement oddCount
        oddCount -= nums[left] % 2;
        left++;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STEP 3: Count ALL subarrays ending at 'right'
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  WHY (right - left + 1)?                                   â”‚
      // â”‚                                                            â”‚
      // â”‚  Window: [left ... right]                                  â”‚
      // â”‚                                                            â”‚
      // â”‚  All valid subarrays ENDING at 'right':                    â”‚
      // â”‚  - [right]                  (length 1)                     â”‚
      // â”‚  - [right-1, right]         (length 2)                     â”‚
      // â”‚  - [right-2, right-1, right](length 3)                     â”‚
      // â”‚  - ...                                                     â”‚
      // â”‚  - [left, ..., right]       (length = right-left+1)        â”‚
      // â”‚                                                            â”‚
      // â”‚  Total = right - left + 1 subarrays                        â”‚
      // â”‚                                                            â”‚
      // â”‚  All these have AT MOST k odd numbers (window is valid)    â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      //
      // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      // â”‚  VISUAL EXAMPLE:                                           â”‚
      // â”‚                                                            â”‚
      // â”‚  Window: [2, 1, 2, 2]  (left=0, right=3, k=1)              â”‚
      // â”‚           0  1  2  3                                       â”‚
      // â”‚                                                            â”‚
      // â”‚  Subarrays ending at right=3:                              â”‚
      // â”‚  - [2]         starting at 3  âœ… 0 odd                     â”‚
      // â”‚  - [2, 2]      starting at 2  âœ… 0 odd                     â”‚
      // â”‚  - [1, 2, 2]   starting at 1  âœ… 1 odd                     â”‚
      // â”‚  - [2, 1, 2, 2] starting at 0 âœ… 1 odd                     â”‚
      // â”‚                                                            â”‚
      // â”‚  Count = 4 = right - left + 1 = 3 - 0 + 1                  â”‚
      // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      count += right - left + 1;
    }

    return count;
  }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN - COMPLETE VISUALIZATION
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Example: nums = [1, 1, 2, 1, 1], k = 3
   *          Index:  0  1  2  3  4
   *          Odd?:   âœ“  âœ“  âœ—  âœ“  âœ“
   *
   * We need: exactly(3) = atMost(3) - atMost(2)
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * CALCULATING atMost(3)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Initial: left=0, oddCount=0, count=0
   *
   * right=0: nums[0]=1 (odd)
   *   oddCount = 0 + 1 = 1
   *   1 <= 3? YES, window valid
   *   count += 0-0+1 = 1
   *   Window: [1]
   *
   * right=1: nums[1]=1 (odd)
   *   oddCount = 1 + 1 = 2
   *   2 <= 3? YES, window valid
   *   count += 1-0+1 = 2 â†’ count = 3
   *   Window: [1, 1]
   *
   * right=2: nums[2]=2 (even)
   *   oddCount = 2 + 0 = 2
   *   2 <= 3? YES, window valid
   *   count += 2-0+1 = 3 â†’ count = 6
   *   Window: [1, 1, 2]
   *
   * right=3: nums[3]=1 (odd)
   *   oddCount = 2 + 1 = 3
   *   3 <= 3? YES, window valid
   *   count += 3-0+1 = 4 â†’ count = 10
   *   Window: [1, 1, 2, 1]
   *
   * right=4: nums[4]=1 (odd)
   *   oddCount = 3 + 1 = 4
   *   4 <= 3? NO! Shrink window
   *     Remove nums[0]=1 (odd): oddCount = 4-1 = 3, left = 1
   *   3 <= 3? YES, window valid
   *   count += 4-1+1 = 4 â†’ count = 14
   *   Window: [1, 2, 1, 1]
   *
   * atMost(3) = 14
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * CALCULATING atMost(2)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Initial: left=0, oddCount=0, count=0
   *
   * right=0: nums[0]=1 (odd)
   *   oddCount = 1
   *   1 <= 2? YES
   *   count += 1 â†’ count = 1
   *
   * right=1: nums[1]=1 (odd)
   *   oddCount = 2
   *   2 <= 2? YES
   *   count += 2 â†’ count = 3
   *
   * right=2: nums[2]=2 (even)
   *   oddCount = 2
   *   2 <= 2? YES
   *   count += 3 â†’ count = 6
   *
   * right=3: nums[3]=1 (odd)
   *   oddCount = 3
   *   3 <= 2? NO! Shrink
   *     Remove nums[0]=1: oddCount = 2, left = 1
   *   2 <= 2? YES
   *   count += 3 â†’ count = 9
   *
   * right=4: nums[4]=1 (odd)
   *   oddCount = 3
   *   3 <= 2? NO! Shrink
   *     Remove nums[1]=1: oddCount = 2, left = 2
   *   2 <= 2? YES
   *   count += 3 â†’ count = 12
   *
   * atMost(2) = 12
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * FINAL CALCULATION
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * exactly(3) = atMost(3) - atMost(2)
   *            = 14 - 12
   *            = 2 âœ…
   *
   * The 2 subarrays with exactly 3 odd numbers:
   * 1. [1, 1, 2, 1] indices 0-3
   * 2. [1, 2, 1, 1] indices 1-4
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * DRY RUN 2: nums = [2, 2, 2, 1, 2, 2, 1, 2, 2, 2], k = 2
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * Index: 0  1  2  3  4  5  6  7  8  9
   * Odd?:  âœ—  âœ—  âœ—  âœ“  âœ—  âœ—  âœ“  âœ—  âœ—  âœ—
   *
   * atMost(2):
   *   Window can include up to 2 odd numbers
   *   Most of the time, window spans entire array or large portion
   *
   *   right=0 to 9: count accumulates as window expands
   *   Shrinking only happens when we hit 3rd odd (never in this case!)
   *
   *   Total = 1+2+3+4+5+6+7+8+9+10 = 55
   *
   * atMost(1):
   *   Window can include up to 1 odd number
   *
   *   right=0,1,2: No odd yet, window grows
   *   right=3: Hit first odd, still valid (1 <= 1)
   *   right=4,5: Window includes indices 0-5 (1 odd)
   *   right=6: Second odd! Shrink until only 1 odd
   *            left moves to index 4 (after first odd)
   *   right=7,8,9: Window stays from 4-9 (1 odd at index 6)
   *
   *   Total = 1+2+3+4+5+6+3+4+5+6 = 39
   *
   * exactly(2) = atMost(2) - atMost(1) = 55 - 39 = 16 âœ…
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * WHY IS THIS O(n)?
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  Each element is:                                              â”‚
   * â”‚  - Added to window once (when right reaches it)                â”‚
   * â”‚  - Removed from window at most once (when left passes it)      â”‚
   * â”‚                                                                â”‚
   * â”‚  Total operations = 2n â†’ O(n)                                  â”‚
   * â”‚                                                                â”‚
   * â”‚  We call atMost twice â†’ 2 Ã— O(n) = O(n)                        â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   *
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * COMPARISON WITH BINARY SUBARRAYS WITH SUM
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   * â”‚  Binary Subarrays:              Nice Subarrays:                            â”‚
   * â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
   * â”‚  sum += nums[right]             oddCount += nums[right] % 2                â”‚
   * â”‚  sum -= nums[left]              oddCount -= nums[left] % 2                 â”‚
   * â”‚                                                                             â”‚
   * â”‚  LITERALLY THE SAME ALGORITHM!                                              â”‚
   * â”‚  Just different way of "counting 1s"                                        â”‚
   * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   */

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TEST CASES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  export function runTests(): void {
    console.log('ğŸ§ª Testing Count Nice Subarrays - SLIDING WINDOW (AT MOST K)\n');
    console.log('â•'.repeat(60) + '\n');

    const testCases: {
      nums: number[];
      k: number;
      expected: number;
      description: string;
    }[] = [
      // Examples from problem
      {
        nums: [1, 1, 2, 1, 1],
        k: 3,
        expected: 2,
        description: 'Example 1 - basic case',
      },
      {
        nums: [2, 4, 6],
        k: 1,
        expected: 0,
        description: 'Example 2 - all even numbers',
      },
      {
        nums: [2, 2, 2, 1, 2, 2, 1, 2, 2, 2],
        k: 2,
        expected: 16,
        description: 'Example 3 - evens padding both sides',
      },

      // Edge cases
      {
        nums: [1],
        k: 1,
        expected: 1,
        description: 'Single odd element',
      },
      {
        nums: [2],
        k: 1,
        expected: 0,
        description: 'Single even element',
      },
      {
        nums: [1, 1, 1],
        k: 1,
        expected: 3,
        description: 'All odd, k=1',
      },
      {
        nums: [1, 1, 1],
        k: 2,
        expected: 2,
        description: 'All odd, k=2',
      },
      {
        nums: [1, 1, 1],
        k: 3,
        expected: 1,
        description: 'All odd, k=3',
      },

      // Even numbers extending
      {
        nums: [2, 1, 2],
        k: 1,
        expected: 4,
        description: 'One odd with even padding (2Ã—2=4)',
      },
      {
        nums: [2, 2, 1, 2, 2],
        k: 1,
        expected: 9,
        description: 'One odd, many evens (3Ã—3=9)',
      },

      // Mixed cases
      {
        nums: [1, 2, 1, 2, 1],
        k: 2,
        expected: 4,
        description: 'Alternating odd-even',
      },
      {
        nums: [2, 1, 2, 1, 2],
        k: 2,
        expected: 4,
        description: 'Evens around two odds',
      },
    ];

    let passed = 0;
    let failed = 0;

    for (let i = 0; i < testCases.length; i++) {
      const { nums, k, expected, description } = testCases[i];
      const result = numberOfSubarrays(nums, k);
      const status = result === expected ? 'âœ… PASS' : 'âŒ FAIL';

      if (result === expected) {
        passed++;
      } else {
        failed++;
      }

      console.log(`Test ${i + 1}: ${status}`);
      console.log(`  Description: ${description}`);
      console.log(`  Input: nums = [${nums}], k = ${k}`);
      console.log(`  Expected: ${expected}`);
      console.log(`  Got: ${result}`);
      console.log();
    }

    console.log('â•'.repeat(60));
    console.log(`\nğŸ“Š Results: ${passed} passed, ${failed} failed\n`);

    if (failed === 0) {
      console.log('ğŸ‰ All tests passed! Sliding Window samajh aa gaya! ğŸš€');
      console.log('ğŸ“Š Complexity: Time O(n), Space O(1)');
      console.log('\nğŸ’¡ Key Formula: exactly(k) = atMost(k) - atMost(k-1)');
      console.log('ğŸ’¡ Same pattern as Binary Subarrays With Sum!');
    }
  }
}

// Execute tests
CountNiceSubarraysOptimal.runTests();